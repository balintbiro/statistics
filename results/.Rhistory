#position frequency matrix
pfm.count<-consensusMatrix(numt_ends, baseOnly=T)[1:4,]
pfm<-PFMatrix(name='numt_ends', profileMatrix=pfm.count)
#information content matrix
icm<-toICM(pfm, pseudocounts=0)
#create sequence logo; ic.scale refers to information content scale in bits
seqLogo(icm, ic.scale=TRUE)
numt_ends<-scan('Z:/balint/numt/numt_mt_ends.fasta', what="")
numt_ends<-DNAStringSet(numt_ends)
#create consensus
consensusMatrix(numt_ends, baseOnly=TRUE)
#position frequency matrix
pfm.count<-consensusMatrix(numt_ends, baseOnly=T)[1:4,]
pfm<-PFMatrix(name='numt_ends', profileMatrix=pfm.count)
#information content matrix
icm<-toICM(pfm, pseudocounts=0)
#create sequence logo; ic.scale refers to information content scale in bits
seqLogo(icm, ic.scale=TRUE)
package_version("RIdeogram")
library(Biostrings)
library(TFBSTools)
package_version("Biostrings")
package_version("TFBSTools")
package_version(TFBSTools)
library(Biostrings)
library(Biostrings)
library(Biostrings)
library(TFBSTools)
library(RIdeogram)
packageDescription(Biostrings)
library(TFBSTools)
package_info(pkgs=NULL)
package_version(TFBSTools)
library(Biostrings)
library(TFBSTools)
library(RIdeogram)
Biostrings
packageVersion("Biostrings")
packageVersion("TFBSTools")
packageVersion("RIdeogram")
#get a defined size of sample from a vector
my_sample<-sample(1000, 20)
my_sample
len(my_sample)
length(my_sample)
#get a defined size of sample from a vector
my_sample<-sample(1000,
20)
length(my_sample)
#get a defined size of sample from a vector
my_sample<-sample(100,#vector is from 1 to 1000
20)#sample size
length(my_sample)
my_sample
#cumulative frequency with ordinal vairables
my_sample<-table(123,210,212,321,213)
my_sample
#cumulative frequency with ordinal vairables
my_sample<-table((123,210,212,321,213),(1,2,3,4,5))
#cumulative frequency with ordinal vairables
my_sample<-table([123,210,212,321,213],[1,2,3,4,5])
#cumulative frequency with ordinal vairables
my_sample<-table([123,210,212,321,213][1,2,3,4,5])
#cumulative frequency with ordinal vairables
my_sample<-c(123,210,212,321,213)
my_sample
cumsum(my_sample)
scale(my_sample)
#standardisation x-mean(x)/sd(x)
scale(my_sample)
#standardisation x-mean(x)/sd(x)
standardized<-scale(my_sample)
standardized
#ranking
ranked<-rank(my_sample)
ranked
#calculating means
my_mean<-mean(my_sample)
my_mean
#dealing with missing values
my_sample<-c(12,32,412,NA,98,89)
na_positions<-is.na(my_sample)
na_positions
na_positions<-which(na_positions)
na_positions
#dealing with missing values
my_sample<-c(12,32,412,NA,98,89)
is_na<-is.na(my_sample)
na_positions<-which(is_na)
na_positions
my_sample_naless<-my_sample[-na_positions]
my_sample_naless
boxplot.stats(my_sample)
library(TeachingDemos)
install.packages(TeachingDemos)
install.packages(TeachingDemos)
install.packages("TeachingDemos")
library(TeachingDemos)
my_variable<-c(1,2,1,3,1,4,1,3,1,2,3,2,3,4,1,2,32,4,5,2,5,6,3,1,3,31,1,2,3,3,21,2)
my_variable
return(z_score)
lapply(my_variable, calc_z_score(mean(my_variable),sd(my_variable)))
#define a function for calculating z scores for every data point in a given variable
calc_z_score <- function(input_mean, input_sd, input_value){
z_score<-(input_value-input_mean)/input_sd
return(z_score)
}
my_variable<-c(2,2,3,2,5,1,6)
#define a function for calculating z scores for every data point in a given variable
calc_z_score <- function(input_mean, input_sd, input_value){
z_score<-(input_value-input_mean)/input_sd
return(z_score)
}
lapply(my_variable, calc_z_score(mean(my_variable),sd(my_variable)))
#define a function for calculating z scores for every data point in a given variable
calc_z_score <- function(input_variable, input_element){
z_score<-(input_element-mean(input_variable))/sd(input_variable)
return(z_score)
}
lapply(my_variable, calc_z_score(my_variable))
lapply(my_variable, calc_z_score)
#define a function for calculating z scores for every data point in a given variable
calc_z_score <- function(input_variable){
z_score<-(input_element-mean(input_variable))/sd(input_variable)
return(z_score)
}
lapply(my_variable, calc_z_score)
z_score<-input_variable*2
#define a function for calculating z scores for every data point in a given variable
calc_z_score <- function(input_variable){
z_score<-input_variable*2
return(z_score)
}
sapply(my_variable,calc_z_score)
z_score<-(input_element-mean(input_variable))/sd(input_variable)
#define a function for calculating z scores for every data point in a given variable
calc_z_score <- function(input_element, input_variable){
z_score<-(input_element-mean(input_variable))/sd(input_variable)
return(z_score)
}
sapply(my_variable,calc_z_score)
sapply(my_variable,calc_z_score(my_variable))
z_score<-(input_element-mean(input_variable))/sd(input_variable)
#define a function for calculating z scores for every data point in a given variable
calc_z_score <- function(input_element, input_variable){
z_score<-(input_element-mean(input_variable))/sd(input_variable)
return(z_score)
}
sapply(my_variable,calc_z_score(my_variable))
#define a function for calculating z scores for every data point in a given variable
calc_z_score <- function(input_element){
z_score<-input_element*2
return(z_score)
}
sapply(my_variable,calc_z_score)
calc_z_score <- function(input_element,input_variable){
z_score<-(input_element-mean(input_variable))/sd(input_variable)
return(z_score)
}
sapply(my_variable,calc_z_score, input_variable=my_variable)
#apply the previously defined function to all element in a variable
z_scores<-sapply(my_variable,calc_z_score, input_variable=my_variable)
z_scores
#calculating the mean of the variable
my_sum<-0
sum(my_variable)
#define a simple variable
my_variable<-c(2,2,3,2,5,1,6)
#define a global variable for sum
my_sum<-0
sum(my_variable)
#function for calculating mean
calc_mean<-function(element, my_variable){
my_sum+=element
return(my_sum/length(my_variable))
}
#function for calculating mean
calc_mean<-function(element, my_variable){
my_sum+=element
return(my_sum/length(my_variable))
}
#function for calculating mean
calc_mean<-function(element, my_variable){
my_sum+=element
return(my_sum/length(my_variable))
}
#function for calculating mean
calc_mean<-function(element, my_variable){
my_sum+=element
return(my_sum/length(my_variable))
}
#function for calculating mean
calc_mean<-function(element, my_variable){
my_sum+=element
return(my_sum/length(my_variable))
}
#define a function for calculating z scores for every data point in a given variable
calc_z_score <- function(input_element,input_variable){
z_score<-(input_element-mean(input_variable))/sd(input_variable)
return(z_score)
}
#function for calculating mean
calc_mean<-function(element, my_variable){
my_sum+=element
my_mean<-my_sum/length(my_variable)
return(my_mean)
}
length(my_variable)
#define a simple variable
my_variable<-c(2,2,3,2,5,1,6)
mean(my_variable)
sd(my_variable)
#define global variable for sd calculation
my_sum<-0
my_sum
sd(my_variable)
#define a simple variable
my_variable<-c(2,2,3,2,5,1,6)
#define a function for calculating z scores for every data point in a given variable
calc_z_score <- function(input_element,input_variable){
z_score<-(input_element-mean(input_variable))/sd(input_variable)
return(z_score)
}
#apply the previously defined function to all element in a variable
z_scores<-sapply(my_variable,calc_z_score, input_variable=my_variable)
z_scores
my_sample<-sample(population,size=10,replace=FALSE)
#define a simple variable
population<-c(2,1,3,1,2,3,1,3,4,5,1,1,3,4,5,2,3,4,5,2,3,2,4,1,3,4,4,2,4,5,45,3,2,1,5)
#setting the seed
set.seed(1)
my_sample<-sample(population,size=10,replace=FALSE)
my_sample
#define a function for calculating z scores for every data point in a given variable
calc_z_score <- function(input_element,input_variable){
z_score<-(input_element-mean(input_variable))/sd(input_variable)
return(z_score)
}
#apply the previously defined function to all element in a variable
z_scores<-sapply(my_sample,calc_z_score, input_variable=my_sample)
z_scores
#define a simple variable
my_population<-c(2,1,3,1,2,3,1,3,4,5,1,1,3,4,5,2,3,4,5,2,3,2,4,1,3,4,4,2,4,5,45,3,2,1,5)
#setting the seed
set.seed(1)
my_sample<-sample(population,size=10,replace=FALSE)
#define a function for calculating z scores for every data point in a given variable
calc_z_score <- function(input_element,sample,population){
z_score<-(input_element-mean(population))/(sd(population)/length(sample))
return(z_score)
}
#apply the previously defined function to all element in a variable
z_scores<-sapply(my_sample,calc_z_score, population=my_population)
#apply the previously defined function to all element in a variable
z_scores<-sapply(my_sample,calc_z_score, sample=my_sample,population=my_population)
z_scores
length(my_sample)
my_sample
#define a function for calculating t scores for every data point in a given variable
calc_t_score <- function(input_element,sample,population){
t_score<-(input_element-mean(population))/(sd(sample)/length(sample))
return(t_score)
}
#apply the previously defined function to all element in a variable
t_scores<-sapply(my_sample,calc_t_score, sample=my_sample,population=my_population)
t_scores
#create variable
my_variable<-c(123,120,120,121,124,231,210,215,542,21,121,213,102,654,332,432,546,767,877,657,879,321,123,435,654,657,433,767,456)
#set seed for consistency/reproducibility
set.seed(1)
#number of required samplesize for bootstraping (=length of my_sample)
samplesize<-length(my_variable)
#number of repetition for bootstraping
repetitions<-10000
#sample the variable for the required times with replacement and load the results into a matrix
bootstrap_samples<-matrix(sample(my_variable, size=samplesize*repetitions, replace = TRUE),
ncol=repetitions, nrow=samplesize)
dim(bootstrap_samples)#check the dimsensions of our matrix
#calculate the mean for every bootstrap samples (it will give 10000 means)
bootstrap_means<-colMeans(bootstrap_samples)
#visualize means distribution
boxplot(bootstrap_means)
#building a bootstrap confidence interval with the percentile method
lower_ci_limit<-quantile(bootstrap_means, prob=0.025)
higher_ci_limit<-quantile(bootstrap_means, prob=0.975)
lower_ci_limit, higher_ci_limit
lower_ci_limit
higher_ci_limit
ci(my_variable)
library(gmodels)
ci(my_variable)
proba<-2^2
proba
norm_dist<-function(element,mean,sd){
y_value<-(1/(sqrt(2*3.14*sd)))*e^((-(element-mean)^2)/2*sd^2)
return(y_value)
}
my_variable<-c(1,2,3,4,1,2,3,1,3,3,4,2,4,2,4,4,2,2,1,3,3,2,1,2,3,4,2,2,1,3,4,2,1)
lapply(my_variable,norm_dist,mean=mean(my_variable),sd=sd(my_variable))
norm_dist<-function(element,mean,sd){
y_value<-(1/(sqrt(2*3.14*sd)))*exp(1)^((-(element-mean)^2)/2*sd^2)
return(y_value)
}
my_variable<-c(1,2,3,4,1,2,3,1,3,3,4,2,4,2,4,4,2,2,1,3,3,2,1,2,3,4,2,2,1,3,4,2,1)
lapply(my_variable,norm_dist,mean=mean(my_variable),sd=sd(my_variable))
distribution<-lapply(my_variable,norm_dist,mean=mean(my_variable),sd=sd(my_variable))
distribution
distributions
distribution
boxplot(distribution)
hist(distribution)
typeof(distribution)
distribution<-c(distribution)
hist(distribution)
distribution
distribution[0]
distribution[1:4]
distribution[1]
my_variable<-c(1,2,3,4,1,2,3,1,3,)
my_variable<-c(1,2,3,4,1,2,3,1,3)
distribution<-lapply(my_variable,norm_dist,mean=mean(my_variable),sd=sd(my_variable))
distribution<-c(distribution)
hist(distribution)
hist(distribution)
norm_dist<-function(element,mean,sd){
y_value<-(1/(sqrt(2*3.14*sd)))*exp(1)^((-(element-mean)^2)/2*sd^2)
return(y_value)
}
my_variable<-c(1:2000)
distribution<-lapply(my_variable,norm_dist,mean=mean(my_variable),sd=sd(my_variable))
hist(distribution)
distribution
my_variable
my_variable<-c(1:2000,50)
my_variable
my_variable<-c([1:2000],50)
my_variable<-[1:2000],50
my_variable<-[1:2000]
c(
my_variable<-c([1:2000],50)
my_variable<-seq(from=1,to=50,by=2000/50)
my_variable
2000/50
50/2000
my_variable<-seq(from=1,to=50,by=50/2000)
my_variable
distribution<-lapply(my_variable,norm_dist,mean=mean(my_variable),sd=sd(my_variable))
distribution
my_variable<-seq(1,50,length.out=2000)
my_variable
distribution
typeof(distribution)
distribution[1:4]
my_variable[1:4]
norm_dist<-function(element,mean,sd){
y_value<-1/sqrt(2*3.14*sd)*exp(1)^((-(element-mean)^2)/2*sd^2)
return(y_value)
}
my_variable<-seq(1,50,length.out=2000)
distribution<-lapply(my_variable,norm_dist,mean=mean(my_variable),sd=sd(my_variable))
distribution
exp(1)
norm_dist<-function(element,mean,sd){
y_value<-1/sqrt(2*pi*sd)*exp(1)^((-(element-mean)^2)/2*sd^2)
return(y_value)
}
my_variable<-seq(1,50,length.out=2000)
distribution<-lapply(my_variable,norm_dist,mean=mean(my_variable),sd=sd(my_variable))
distribution
my_variable<-seq(50,100,length.out=2000)
distribution<-lapply(my_variable,norm_dist,mean=mean(my_variable),sd=sd(my_variable))
distribution
pi
prob_dens<-(pi*sd)*exp(-0.5*((element-mean)/sd)**2)
return(y_value)
norm_dist<-function(element,mean,sd){
prob_dens<-(pi*sd)*exp(-0.5*((element-mean)/sd)**2)
return(y_value)
}
my_variable<-seq(50,100,length.out=2000)
distribution<-lapply(my_variable,norm_dist,mean=mean(my_variable),sd=sd(my_variable))
norm_dist<-function(element,mean,sd){
y_value<-(pi*sd)*exp(-0.5*((element-mean)/sd)**2)
return(y_value)
}
my_variable<-seq(50,100,length.out=2000)
distribution<-lapply(my_variable,norm_dist,mean=mean(my_variable),sd=sd(my_variable))
dsignrank()
distribution
my_variable<-seq(1,50,length.out=2000)
distribution<-lapply(my_variable,norm_dist,mean=mean(my_variable),sd=sd(my_variable))
distribution
distribution[1:4]
my_variable<-c(seq(1,50,length.out=2000))
distribution<-lapply(my_variable,norm_dist,mean=mean(my_variable),sd=sd(my_variable))
distribution[1:4]
z.test(my_population,99,5)
library(TeachingDemos)
#one sample version
#in this case we compare population mean (u) to a hypothetical value (u0)
#H0 is that u=u0
#H1 two sided u!=u0
#H1 ones sided u>u0; u<u0
my_population<-c(1,3,1,3,4,1,1,2,4,1,2,3,4,1,2,4,2,4,2,1,3,4,4,1,3,4)
z.test(my_population,99,5)
z.test(my_population,mu=99,stdev=5)
z.test(my_population,mu=2.5,stdev=5)#mu and stdev are hypothetical values
z.test(my_population,mu=16,stdev=5)#mu and stdev are hypothetical values
z.test(my_population,mu=16,stdev=5,conf.level=0.95)#mu and stdev are hypothetical values
z.test(my_population,mu=16,stdev=5,conf.level=95)#mu and stdev are hypothetical values
z.test(my_population,mu=16,stdev=5,conf.level=0.95)#mu and stdev are hypothetical values
z_score_calc<-function(variable,mu,sigma){
z_score<-(mean(variable)-mu)/(sigma/sqrt(length(variable)))
}
z_score_calc(my_population,mu=16,sigma=5)
proba<-z_score_calc(my_population,mu=16,sigma=5)
proba
z.test(my_population,mu=16,stdev=5,conf.level=0.95)#mu and stdev are hypothetical values
z_score<-z_score_calc(my_population,mu=16,sigma=5)
z_score
return(z_score)
#two sample version
#condition(s) of usage:
#-normally distributed variables with known standard deviations-->population SD so sigma
#defining own function for two sample z stat calculation
z_score_calc<-function(sample1,sample2,population1,population2){
x1<-mean(sample1)
x2<-mean(sample2)
sigma1<-sd(population1)
sigma2<-sd(population2)
n1<-length(sample1)
n2<-length(sample2)
z_score<-(x1-x2)/sqrt((sigma1/n1)+(sigma2/n2))
return(z_score)
}
population2<-c(1,2,3,4,2,1,3,4,2,2,4,5,3,4,2,2,3,4,5,3,2,1,2,3,4,5,3,2,3,4,2,3,4,3)
length(population2)
length(population1)
population1<-c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1)
length(population1)
population2<-c(1,2,3,4,2,1,3,4,2,2,4,5,3,4,2,2,3,4,5,3,2,1,2,3,4,5,3,2,3,4,2)
length(population2)
population2<-c(1,2,3,4,2,1,3,4,2,2,4,5,3,4,2,2,3,4,5,3,2,1,2,3,4,5,3,2,3)
length(population2)
length(population1)
sample1<-sample(population1,size=15,replace=FALSE)
sample2<-sample(population2,size=15,replace=FALSE)
sample1
sample2
z_score<-z_score_calc(sample1=sample1,
sample2=sample2,
population1=population1,
population2=population2)
z_score
z_score
#do the two sampeld z test with built in function
z_score<-z.test(x=population1,
y=population2,
sigma.x=sd(population1),
sigma.y=sd(population2))
#do the two sampeld z test with built in function
z_score<-z.test(x=population1,
sigma.x=sd(population1),
y=population2,
sigma.y=sd(population2))
#do the two sampeld z test with built in function
z_score<-z.test(x=population1,
sigma.x=sd(population1),
y=population2,
sigma.y=sd(population2),
conf.level=0.95)
x <- c(7.8, 6.6, 6.5, 7.4, 7.3, 7., 6.4, 7.1, 6.7, 7.6, 6.8)
y <- c(4.5, 5.4, 6.1, 6.1, 5.4, 5., 4.1, 5.5)
z.test(x, sigma.x=0.5, y, sigma.y=0.5, conf.level=0.90)
x <- c(7.8, 6.6, 6.5, 7.4, 7.3, 7., 6.4, 7.1, 6.7, 7.6, 6.8)
y <- c(4.5, 5.4, 6.1, 6.1, 5.4, 5., 4.1, 5.5)
z.test(x, sigma.x=0.5, y, sigma.y=0.5, conf.level=0.90)
#do the two sampeld z test with built in function
z_score<-z.test(x=population1,
sigma.x=sd(population1),
y=population2,
sigma.y=sd(population2),
mu=3,
conf.level=0.95)
#do the two sampeld z test with built in function
z_score<-z.test(x=population1,
sigma.x=sd(population1),
y=population2,
sigma.y=sd(population2),
conf.level=0.95)
#qqplot
#quantile is a "line" which divides the datapoints into equally sized groups
#for example percentiles are quantiles which divide the data into 100 equally sized groups
#built in qq plot for comparing quantiles of two variables
setwd('../statistics/results/')
set.seed(1)
population<-seq(1,1000,1)
var_a<-sample(population,size=100,replace=TRUE)
var_b<-sample(population,size=100,replace=TRUE)
png(file='qqplot_built_in.png')
par(mar=c(1, 1, 1, 1))
qqplot(var_a,var_b)
abline(0,1)
dev.off()
#diy qqplot for comparing quantiles of two variables
#sort the variables and then plot them
var1<-sort(var_a,decreasing=FALSE)
var2<-sort(var_b,decreasing=FALSE)
png(file='qqplot_diy.png')
plot(var1,var2)
abline(0,1)
dev.off()
